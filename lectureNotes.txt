








‚äº¬≤.üìπ unit 5.8: handling arrays
	array construction
		var Array arr; ‚Üí allocate local variable, initialize to 0
			generates no code. only affects symbol table
		later on in the program, if we want to construct array with:
			let arr = Array.new(5);
			‚Üí allocate sufficient space in the heap with base addr local0
			from caller's perspective handled exactly like object construction
	THIS‚ÜêRAM[3] and THAT‚ÜêRAM[4] reminder.
		holds addr to this and that segments
		portable, park wherever we want in the RAM
		this ‚Üê current object values
			base addr THIS, set with pop pointer 0
		that ‚Üê values of current array.
			base addr THAT, set with pop pointer 1
	RAM access using 'that'
		// RAM[8056] = 17
		push 8056
		pop pointer 1
		push 17
		pop that 0

		pop pointer 1 ‚Üê sets 'that' = stack.pop()
			aligns 0 with the RAM address whose value is THAT
		pop that 0
			sets 'that 0' = stack.pop()
			sets RAM address aligned with 'that 0' to the same value

	array access
		// arr[2] = 17
		push arr  # base address
		push 2  # offset
		add
		pop pointer 1
		push 17
		pop that 0

		note we only use 'that 0' but not 'that n'
			we could have written this instead:
				push arr
				pop pointer 1
				push 17
				pop that 2
			but this only works when the array index is constant:
				arr[x]=y doesn't work
		note the VM code knows nothing about the host RAM
			code is safe and should run on different platforms
			can't make assumptions on underlying hardware platforms
			virtue of working with virtual machine

	arr[expression‚ÇÅ] = expression‚ÇÇ
		push arr
		push expression‚ÇÅ
		add
		pop pointer 1
		push expression‚ÇÇ
		pop that 0

		but there's a problem here: a[i] = b[j]
			push a
			push i
			add
			pop pointer 1

			# now handle the right side
			push b
			push j
			add
			pop pointer 1 ‚Üê crash! pointer 1 overrides previous address

		let's create a tmp variable to store
			push a
			push i
			add

			push b
			push j
			add

			# now stack contains RAM addresses of a[i] and b[j]
			pop pointer 1
			pop temp 0  # store b[j]
			pop pointer 1  # now we can pop addr of a[i] onto 'that'
			push temp 0  # b[j] ‚Üí stack
			pop that 0

		generalizing solution: works for infinite nesting?
			push arr
			VM code for computing and pushing value of expression‚ÇÅ
			add
			VM code for computing and pushing value of expression‚ÇÇ
			pop temp 0	# temp 0 = value of expression‚ÇÇ
						# top stack value = RAM address of arr[expression‚ÇÅ]
			pop pointer 1
			push temp 0
			pop that 0



‚äº¬≤.üìπ 5.6 handling objects: construction
	compiler faces challenge of compiling client class, then Point class
		not necessarily in that order!
		let p1 = Point.new(2, 3); ‚Üê caller
		constructor Point new(...) ‚Üê callee
	each object has a spot on the heap
		the stack holds object addresses. these point to the heap
	whenever compiler encounters variable declaration, no code generated
		just updates the subroutine's symbol table
	handling calls to create new objects
	let p1 = Point.new(2, 3)
		push 2
		push 3
		call Point.new
		pop p1 ‚Üê p1 is the base address of the new object
	remember the contract! caller assumes constructor's code
		1. arranges a memory block to store the new object
		2. returns its base address to the caller
	example:
		var Point p1, p2;
		var int d;

		during compile time, compiler maps
			p1 on local 0, p2 on local 1, d on local 2
		during run time, execution of the constructor's code effects creation of objects themselves on the heap

	purpose of constructor
		arrange creation of new object
		initializes new object to some intial state
		‚Üí constructor must have access to object's fields via THIS segment
			but first constructor must anchor THIS using POINTER
	example:
		constructor Point new(int ax, int ay)
		‚Üí generates no code, just creates symbol table for subroutine
		compiler knows it generates code for constructor
			knows constructor must create space in RAM for new object
			how does compiler know how much space is needed?
				by consulting the subroutine symbol table! all values 16-bit
			for ax, ay, we must secure memory block with two words
			OS helps with allocate(n)
				‚Üí finds memory block in RAM n words long that's free!
				implementation is clever and elegant. implement in OS module

		# constructor Point new(int ax, int ay)
			push 2 ‚Üê two 16-bit words required (x and y)
			call Memory.alloc 1 ‚Üê one argument (the 2 we just pushed)
				# returns base address of newly created object
			pop pointer 0 ‚Üê THIS now points to addr of new object!

		# let x = ax; let y = ay ‚Üê put arguments into new object :3
			push argument 0
			pop this 0
			push argument 1
			pop this 1

		# let pointCoint = pointCount + 1;
			push static 0
			push 1
			add
			pop static 0

		# return this
			push pointer 0 ‚Üê THIS is already anchored correctly
								and contains base addr of THIS
			return ‚Üê returns base address of newly created object

	# let p1 = Point.new(2,3)
		push 2
		push 3
		call Point.new
		pop p1
		‚Üí after calling Point.new, we pop the new base addr onto p1 :D



‚äº¬≤.üìπ 5.5 handling objects: low-level aspects
	sequence of three units on handling objects!
	let's explore low level aspects of data handling using VM commands
	programmer friendly abstractions! levels of programming languages:
		high, OO: create and manipulate arrays, objects
		mid, VM: operate on virtual memory segments
		low machine language
	everything we do at VM level reduces to operations on the RAM
	first 5 words in RAM are SP LCL ARG THIS THAT
		followed by the stack, then heap
		local and argument variables are stored ‚Üí stack
		objects and array data ‚Üí heap
		in order to access these, we need to anchor THIS and THAT
			use virtual 'pointer' segment instead of THIS and THAT
			üïØ why?
	üåä examples



‚äº¬≤.üìπ 5.4 handling flow of control
	5 possible statements: [while, if] are the challenging ones
		let, do, return are trivial

	if (expression) {statements‚ÇÅ} else {statements‚ÇÇ}
		use a flow chart to rewrite this
		negate if expression:
			if not expression:
				statements‚ÇÇ
			else:
				statements‚ÇÅ

		note that below, the labels must be unique
		VM code
			compiled (expression)
			not ‚Üê negates our expression
			if-goto L1
			compiled (statements‚ÇÅ) ‚Üê executes if expression was true
			goto L2
		label L1
			compiled (statements‚ÇÇ)
		label L2

	while (expression) {statements}
		pseudocode
			negate expression
			if not expression:
				pass
			else:
				statements

		VM code
			label L1
				compiled (expression)
				not
				if-goto L2
				compiled (statements)
				goto L1
			label L2

	minor complications
		program typically containts multiple if and while statements
			thus labels must be unique, perhaps using a counter
		if and while statements are often nested in 'telescopic code'
			a compiler should be able to support infinite nesting given memory
			our compiler's recursive strategy already takes care of this

	compiling variables, expressions, and flow of control
		‚Üí allows us to build array-less simple procedural language
		remember we don't translate down to machine language because ‚ÜíVM
		it's manageable and elegant because we took care of the VM abstraction



‚äº¬≤.üìπ 5.3 handling expressions
	parse trees:
		infix ‚Üê human oriented, source language
			a*(b+c)
		prefix ‚Üê functional notation. function comes first, then arguments
			*a+bc
		postfix ‚Üê stack oriented
			abc+*
	source is infix, compiler translates to postfix for stack machine
	we've already implemented parse tree tech with syntax analyzer's xml output
	depth first tree traversal does this
		go all the way down, push leaf, backtrack, repeat
		we're not using this

	# well-equipped to take infix source and convert to postfix
	codeWrite(expression):
		match expression:
			case number n:
				output 'push n'
			case variable var:
				output 'push var' ‚Üê local 0, static 2. using symbol table
			case 'exp‚ÇÅ op exp‚ÇÇ': use recursion!
				codeWrite(exp‚ÇÅ)
				codeWrite(exp‚ÇÇ)
				output 'op'
			case 'op expression':
				codewrite(expression)
				output 'op'
			case f(exp‚ÇÅ, exp‚ÇÇ, ...):
				codeWrite(exp‚ÇÅ)
				codeWrite(exp‚ÇÇ)
				codeWrite(exp.)
				output 'call f' ‚Üê function call

	üåä take some time to play with a few expressions

	switch from parsing to code generation
	example: let x=a+b*c
		parse tree
		compiler ignores operator priority ‚Üê implementer's choice
		Jack language does not have operator priority
		‚Üí put burden on the user



‚äº¬≤.üìπ unit 5.2 handling variables
	sum = x * (1 + rate)
		push x
		push 1
		push rate
		+
		*
		pop sum

	the VM language does not have symbolic variables
		only local, argument, this, that, etc.
		symbolic variables must be mapped to virual memory segments
			are sum, x, and rate field, static, local, or argument variables
	class-level variables: field, static
	subroutine-level variables: local, argument
	variable properties:
		name (identifier)
		type (int, char, boolean, class name)
		kind (field, static, local, argument)
		scope (class level, subroutine level)

	bundle of variable properties that must be maintained for every var in src
	the symbol table not only includes the kind of a variable, but also which number of that kind each variable is.

	every method subroutine has this as the first entry of its symbol table
		its kind of argument

	high level programming languages vary in terms of variable
		types, kinds, and scoping

	unlimited nested scoping can be handled with a linked list of symbol tables



‚äº¬≤ 5.1 code generation
	compiler II: code generation
	syntax analyzer: tokenizer + compilation engine (parser)
		XML meant to verify syntax analyzer understands syntactic structure
	project 11 throws out XML code. new goal:
		extend basic syntax anlyzer to adding code generation ability
		passive XML code ‚Üí morph into executable VM code
	each Jack class file compiled separately
	class: point
		class declaration ‚Üí {classVarDec*  subroutineDec*}

	compilation	is two separate and standalone steps:
		localized! modular strategy
		compile class-level code ‚Üê classVarDec*
		compile one subroutine at a time ‚Üê subroutineDec*
			we have 5 challenges: generate VM code to capture these semantics:
				challenge is bridging gap between simple VM code
					with complicated high-level language
			variables, expressions, flow of control, objects, arrays

	we will learn how programming languages work
		handle arrays and objects in low-level
		general techniques
			parsing
			recursive compilation
			code generation
			symbol tables
			memory management